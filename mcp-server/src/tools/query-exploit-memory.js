// Copyright (C) 2025 Keygraph, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License version 3
// as published by the Free Software Foundation.

/**
 * query_exploit_memory MCP Tool
 *
 * Queries the exploit memory database for historical vulnerabilities,
 * exploitation attempts, discovered credentials, and attack patterns.
 */

import { tool } from '@anthropic-ai/claude-agent-sdk';
import { z } from 'zod';
import { createToolResult } from '../types/tool-responses.js';
import { createGenericError } from '../utils/error-formatter.js';
import {
  getDatabase,
  queryVulnerabilities,
  getApplication,
  getPatterns,
  queryCredentials
} from '../../../src/exploit-memory/database.js';

/**
 * Input schema for query_exploit_memory tool
 */
export const QueryExploitMemoryInputSchema = z.object({
  hostname: z.string().min(1).describe('Target hostname to query'),
  vuln_type: z.string().optional().describe('Filter by vulnerability type (e.g., sql_injection, xss)'),
  remediation_status: z.string().optional().describe('Filter by remediation status (open, fixed, verified)'),
  min_confidence: z.number().min(0).max(100).optional().describe('Minimum confidence score (0-100)'),
  max_age_days: z.number().positive().optional().describe('Maximum age in days for results'),
  include_credentials: z.boolean().optional().default(false).describe('Include discovered credentials'),
  include_patterns: z.boolean().optional().default(true).describe('Include successful attack patterns')
});

/**
 * Query exploit memory database
 *
 * @param {Object} args
 * @param {string} args.hostname - Target hostname
 * @param {string} [args.vuln_type] - Vulnerability type filter
 * @param {string} [args.remediation_status] - Remediation status filter
 * @param {number} [args.min_confidence] - Minimum confidence filter
 * @param {number} [args.max_age_days] - Maximum age filter
 * @param {boolean} [args.include_credentials] - Include credentials
 * @param {boolean} [args.include_patterns] - Include patterns
 * @returns {Promise<Object>} Tool result
 */
export async function queryExploitMemory(args) {
  try {
    const {
      hostname,
      vuln_type,
      remediation_status,
      min_confidence,
      max_age_days,
      include_credentials = false,
      include_patterns = true
    } = args;

    // Get database connection
    const db = getDatabase(hostname);

    // Get application info
    const application = getApplication(db, hostname);

    // Query vulnerabilities with filters
    const vulnerabilities = queryVulnerabilities(db, {
      hostname,
      vuln_type,
      remediation_status,
      min_confidence,
      max_age_days
    });

    // Build response
    const response = {
      status: 'success',
      hostname,
      application_info: application,
      vulnerabilities: vulnerabilities.map(v => ({
        id: v.id,
        vuln_type: v.vuln_type,
        source: v.source,
        path: v.path,
        sink_call: v.sink_call,
        confidence: v.confidence,
        remediation_status: v.remediation_status,
        first_discovered_at: v.first_discovered_at,
        last_verified_at: v.last_verified_at,
        exploitation_data: v.exploitation_data
      })),
      total_vulnerabilities: vulnerabilities.length,
      statistics: calculateStatistics(vulnerabilities)
    };

    // Include attack patterns if requested
    if (include_patterns) {
      const patterns = getPatterns(db, hostname);
      response.attack_patterns = patterns.map(p => ({
        pattern_type: p.pattern_type,
        pattern_data: p.pattern_data,
        success_count: p.success_count,
        last_used_at: p.last_used_at
      }));
      response.total_patterns = patterns.length;
    }

    // Include credentials if requested
    if (include_credentials) {
      const credentials = queryCredentials(db, hostname);
      response.discovered_credentials = credentials.map(c => ({
        id: c.id,
        credential_type: c.credential_type,
        service_type: c.service_type,
        username: c.username,
        discovered_via: c.discovered_via,
        discovered_at: c.discovered_at,
        validated: c.validated === 1,
        host: c.host,
        port: c.port,
        metadata: c.metadata
        // Note: password_hash and connection_string excluded for security
      }));
      response.total_credentials = credentials.length;
    }

    // Add tech stack if available
    if (application?.tech_stack) {
      response.tech_stack = application.tech_stack;
    }

    // Add common weaknesses if available
    if (application?.common_weaknesses) {
      response.common_weaknesses = application.common_weaknesses;
    }

    return createToolResult(response);
  } catch (error) {
    const errorResponse = createGenericError(
      error,
      false,
      { hostname: args.hostname }
    );

    return createToolResult(errorResponse);
  }
}

/**
 * Calculate vulnerability statistics
 *
 * @param {Array} vulnerabilities - List of vulnerabilities
 * @returns {Object} Statistics
 */
function calculateStatistics(vulnerabilities) {
  const stats = {
    by_type: {},
    by_status: {},
    by_confidence: {
      high: 0,   // 80-100
      medium: 0, // 50-79
      low: 0     // 0-49
    },
    average_confidence: 0
  };

  if (vulnerabilities.length === 0) {
    return stats;
  }

  let totalConfidence = 0;

  for (const vuln of vulnerabilities) {
    // Count by type
    stats.by_type[vuln.vuln_type] = (stats.by_type[vuln.vuln_type] || 0) + 1;

    // Count by status
    stats.by_status[vuln.remediation_status] = (stats.by_status[vuln.remediation_status] || 0) + 1;

    // Count by confidence
    if (vuln.confidence >= 80) {
      stats.by_confidence.high++;
    } else if (vuln.confidence >= 50) {
      stats.by_confidence.medium++;
    } else {
      stats.by_confidence.low++;
    }

    totalConfidence += vuln.confidence;
  }

  stats.average_confidence = Math.round(totalConfidence / vulnerabilities.length);

  return stats;
}

/**
 * Tool definition for MCP server
 */
export const queryExploitMemoryTool = tool(
  'query_exploit_memory',
  'Query historical vulnerability data, exploitation attempts, credentials, and attack patterns from previous test sessions. Use this to learn from past findings and avoid duplicate work.',
  QueryExploitMemoryInputSchema.shape,
  queryExploitMemory
);
