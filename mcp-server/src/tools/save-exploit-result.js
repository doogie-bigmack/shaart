// Copyright (C) 2025 Keygraph, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License version 3
// as published by the Free Software Foundation.

/**
 * save_exploit_result MCP Tool
 *
 * Saves exploitation results to the exploit memory database.
 * Handles vulnerability deduplication, exploitation attempts, and credential discovery.
 */

import { tool } from '@anthropic-ai/claude-agent-sdk';
import { z } from 'zod';
import { createToolResult } from '../types/tool-responses.js';
import { createGenericError, createValidationError } from '../utils/error-formatter.js';
import {
  getDatabase,
  upsertApplication,
  upsertVulnerability,
  recordExploitationAttempt,
  recordPattern,
  recordCredentials
} from '../../../src/exploit-memory/database.js';
import {
  generateIdentityHash,
  validateVulnerability,
  normalizeVulnerability
} from '../../../src/exploit-memory/deduplicator.js';
import {
  extractCredentials,
  normalizeCredentials,
  validateCredentials
} from '../../../src/exploit-memory/credential-extractor.js';

/**
 * Input schema for save_exploit_result tool
 */
export const SaveExploitResultInputSchema = z.object({
  hostname: z.string().min(1).describe('Target hostname'),
  session_id: z.string().min(1).describe('Current session ID'),
  vulnerability: z.object({
    vuln_type: z.string().min(1).describe('Vulnerability type (e.g., sql_injection, xss)'),
    source: z.string().min(1).describe('Source file or endpoint'),
    path: z.string().min(1).describe('Path in application'),
    sink_call: z.string().optional().describe('Sink function call'),
    confidence: z.number().min(0).max(100).describe('Confidence score (0-100)'),
    exploitation_data: z.any().optional().describe('Additional exploitation data')
  }).describe('Vulnerability details'),
  exploitation_attempt: z.object({
    success: z.boolean().describe('Whether exploitation was successful'),
    technique: z.string().optional().describe('Technique used'),
    payload: z.string().optional().describe('Payload used'),
    response_snippet: z.string().optional().describe('Response snippet'),
    notes: z.string().optional().describe('Additional notes')
  }).optional().describe('Exploitation attempt details'),
  discovered_credentials: z.array(z.object({
    credential_type: z.string().describe('Type of credential'),
    username: z.string().optional().describe('Username'),
    password: z.string().optional().describe('Password (will be hashed)'),
    connection_string: z.string().optional().describe('Connection string'),
    service_type: z.string().optional().describe('Service type'),
    host: z.string().optional().describe('Host'),
    port: z.number().optional().describe('Port'),
    metadata: z.any().optional().describe('Additional metadata')
  })).optional().describe('Discovered credentials'),
  attack_pattern: z.object({
    pattern_type: z.string().describe('Pattern type'),
    pattern_data: z.any().describe('Pattern data')
  }).optional().describe('Successful attack pattern to record')
});

/**
 * Save exploitation result to database
 *
 * @param {Object} args - Tool arguments
 * @returns {Promise<Object>} Tool result
 */
export async function saveExploitResult(args) {
  try {
    const {
      hostname,
      session_id,
      vulnerability,
      exploitation_attempt,
      discovered_credentials,
      attack_pattern
    } = args;

    // Get database connection
    const db = getDatabase(hostname);

    // Ensure application record exists
    upsertApplication(db, {
      hostname
    });

    // Validate vulnerability
    const vulnValidation = validateVulnerability({
      ...vulnerability,
      hostname
    });

    if (!vulnValidation.isValid) {
      const errorResponse = createValidationError(
        `Invalid vulnerability data: ${vulnValidation.errors.join(', ')}`,
        true,
        { errors: vulnValidation.errors }
      );
      return createToolResult(errorResponse);
    }

    // Normalize and generate hash
    const normalizedVuln = normalizeVulnerability({
      ...vulnerability,
      hostname
    });

    const deduplicationStrategy = global.__SHAART_EXPLOIT_MEMORY_CONFIG?.deduplication_strategy || 'strict';
    const vulnerabilityId = generateIdentityHash(normalizedVuln, deduplicationStrategy);

    // Upsert vulnerability
    const savedVuln = upsertVulnerability(db, {
      id: vulnerabilityId,
      ...normalizedVuln
    });

    const result = {
      status: 'success',
      message: 'Exploitation result saved successfully',
      vulnerability_id: vulnerabilityId,
      vulnerability: savedVuln
    };

    // Record exploitation attempt if provided
    if (exploitation_attempt) {
      const attempt = recordExploitationAttempt(db, {
        vulnerability_id: vulnerabilityId,
        session_id,
        ...exploitation_attempt
      });
      result.exploitation_attempt_id = attempt.id;
      result.exploitation_success = exploitation_attempt.success;
    }

    // Record attack pattern if provided and successful
    if (attack_pattern && exploitation_attempt?.success) {
      const pattern = recordPattern(db, {
        hostname,
        ...attack_pattern
      });
      result.pattern_id = pattern.id;
    }

    // Process discovered credentials if provided
    if (discovered_credentials && discovered_credentials.length > 0) {
      const savedCredentials = [];

      for (const cred of discovered_credentials) {
        // Validate credentials
        const credValidation = validateCredentials({
          ...cred,
          discovered_via: `exploitation_${session_id}`
        });

        if (!credValidation.isValid) {
          console.warn(`Skipping invalid credentials: ${credValidation.errors.join(', ')}`);
          continue;
        }

        // Normalize and save
        const normalizedCred = await normalizeCredentials(
          {
            ...cred,
            discovered_via: `exploitation_${session_id}`
          },
          hostname
        );

        const savedCred = recordCredentials(db, normalizedCred);
        savedCredentials.push({
          id: savedCred.id,
          credential_type: savedCred.credential_type,
          service_type: savedCred.service_type,
          username: savedCred.username
        });
      }

      if (savedCredentials.length > 0) {
        result.discovered_credentials = savedCredentials;
        result.credentials_count = savedCredentials.length;

        // Check if infrastructure testing should be triggered
        const triggerInfrastructure = global.__SHAART_EXPLOIT_MEMORY_CONFIG?.trigger_infrastructure !== false;
        if (triggerInfrastructure) {
          result.trigger_infrastructure = true;
          result.message += '. Infrastructure testing phase should be triggered due to discovered credentials.';
        }
      }
    }

    return createToolResult(result);
  } catch (error) {
    const errorResponse = createGenericError(
      error,
      false,
      {
        hostname: args.hostname,
        vuln_type: args.vulnerability?.vuln_type
      }
    );

    return createToolResult(errorResponse);
  }
}

/**
 * Tool definition for MCP server
 */
export const saveExploitResultTool = tool(
  'save_exploit_result',
  'Save exploitation results including vulnerabilities, attempts, and discovered credentials to the exploit memory database for future reference and pattern recognition.',
  SaveExploitResultInputSchema.shape,
  saveExploitResult
);
