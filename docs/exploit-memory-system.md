# Exploit Memory Database System

## Overview

The Exploit Memory Database is a persistent SQLite-based system that stores vulnerabilities, exploitation attempts, remediation history, and discovered credentials across test sessions. This enables:

- **Deduplication**: Avoid re-testing the same vulnerabilities
- **Pattern Recognition**: Learn from successful attack techniques
- **Historical Context**: Provide agents with past findings for better analysis
- **Credential Management**: Track and utilize discovered credentials
- **Remediation Tracking**: Monitor vulnerability fixes over time

## Architecture

### Database Schema

The exploit memory database consists of 6 tables:

1. **applications**: Tracks tested applications and metadata
2. **vulnerabilities**: Stores unique vulnerabilities with identity hashing
3. **exploitation_attempts**: Records all exploitation attempts
4. **remediation_history**: Tracks remediation status changes
5. **application_patterns**: Stores successful attack patterns
6. **discovered_credentials**: Manages discovered credentials

Database files are stored at: `exploit-memory/{hostname}.db`

### Deduplication System

Vulnerabilities are deduplicated using SHA256 identity hashing:

**Identity Hash Formula:**
```
SHA256(hostname + vuln_type + normalized_source + normalized_path + sink_call)
```

**Normalization Rules:**
- Strip line numbers from source references
- Normalize function parameters
- Case-insensitive path comparison
- Remove query parameters from paths

**Deduplication Strategies:**
- `strict`: Exact match on all components (recommended)
- `loose`: Match only on hostname + type + path
- `both`: Check both strategies for maximum coverage

## Configuration

Add the `exploit_memory` section to your YAML config:

```yaml
exploit_memory:
  enabled: true                      # Enable/disable exploit memory
  deduplication_strategy: strict     # strict | loose | both
  max_age_days: 90                   # Max age for historical data
  trigger_infrastructure: true       # Auto-trigger infrastructure phase
```

See `configs/example-exploit-memory-config.yaml` for a complete example.

## MCP Tools

Three new MCP tools are available to agents:

### 1. query_exploit_memory

Query historical vulnerability data and attack patterns.

**Input:**
```javascript
{
  hostname: "example.com",
  vuln_type: "sql_injection",        // Optional filter
  remediation_status: "open",        // Optional filter
  min_confidence: 80,                // Optional filter
  max_age_days: 90,                  // Optional filter
  include_credentials: true,         // Include credentials
  include_patterns: true             // Include attack patterns
}
```

**Output:**
```javascript
{
  status: "success",
  hostname: "example.com",
  vulnerabilities: [...],
  attack_patterns: [...],
  discovered_credentials: [...],
  tech_stack: [...],
  statistics: { by_type, by_status, by_confidence }
}
```

### 2. save_exploit_result

Save exploitation results including vulnerabilities and credentials.

**Input:**
```javascript
{
  hostname: "example.com",
  session_id: "abc-123",
  vulnerability: {
    vuln_type: "sql_injection",
    source: "api/users.py",
    path: "/api/users",
    sink_call: "db.execute",
    confidence: 95
  },
  exploitation_attempt: {
    success: true,
    technique: "union-based",
    payload: "' UNION SELECT ...",
    response_snippet: "..."
  },
  discovered_credentials: [{
    credential_type: "database",
    service_type: "mysql",
    username: "root",
    password: "password123",
    host: "localhost",
    port: 3306
  }]
}
```

### 3. verify_remediation

Mark vulnerabilities as fixed or verified.

**Input:**
```javascript
{
  hostname: "example.com",
  vulnerability_id: "abc123...",
  new_status: "verified",            // fixed | verified | false_positive | wont_fix
  verification_method: "manual retest",
  notes: "Vulnerability confirmed fixed"
}
```

## Automatic Integration

### Vulnerability Capture

When agents save queue files using `save_deliverable`, vulnerabilities are automatically:

1. Extracted from the JSON queue
2. Deduplicated using identity hashing
3. Saved to the exploit memory database
4. Associated with the current session

### Credential Extraction

When agents save evidence files, credentials are automatically:

1. Extracted using regex patterns for:
   - Database connection strings (MySQL, PostgreSQL, MongoDB, Redis)
   - API keys (AWS, GitHub, Stripe)
   - SSH private keys
   - Environment variables
2. Hashed using bcrypt for security
3. Saved to the discovered_credentials table
4. Optionally trigger infrastructure testing phase

### Prompt Context Injection

Historical data is automatically injected into prompts using the `{{EXPLOIT_MEMORY}}` placeholder:

```
<exploit_memory>
# Historical Vulnerability Data

## sql_injection (3 found)
- **/api/users** (confidence: 95%)
  - Source: api/users.py
  - Sink: db.execute
  - Status: open
  - First discovered: 2025-12-01T10:00:00Z

## Successful Attack Patterns
- **union-based** (used 3 times)
  - Last used: 2025-12-15T14:30:00Z

## Discovered Credentials
- **database** (mysql)
  - Username: root
  - Discovered via: exploitation_abc123
  - Validated: Yes
</exploit_memory>

Use this historical data to:
1. Avoid testing already-verified vulnerabilities
2. Focus on similar patterns that were successful before
3. Build on discovered credentials for deeper exploitation
```

## File Operations

### Database Location

Databases are stored per hostname:
```
exploit-memory/
├── example.com.db
├── test.example.com.db
└── another-site.com.db
```

### File Permissions

Database files are created with `chmod 600` (owner read/write only) for security.

### WAL Mode

SQLite Write-Ahead Logging (WAL) is enabled for better concurrency and crash safety.

## Usage Examples

### Querying Historical Data

Agents can query exploit memory at the start of their execution:

```javascript
// Query all open SQL injection vulnerabilities
const result = await query_exploit_memory({
  hostname: "example.com",
  vuln_type: "sql_injection",
  remediation_status: "open",
  min_confidence: 70,
  include_patterns: true
});

// Use historical patterns to guide testing
for (const pattern of result.attack_patterns) {
  console.log(`Try ${pattern.pattern_type} technique`);
}
```

### Saving Exploitation Results

After successful exploitation:

```javascript
await save_exploit_result({
  hostname: "example.com",
  session_id: current_session_id,
  vulnerability: {
    vuln_type: "sql_injection",
    source: "api/users.py:45",
    path: "/api/users",
    sink_call: "db.execute",
    confidence: 95,
    exploitation_data: {
      description: "SQL injection in user search",
      impact: "Full database access",
      remediation: "Use parameterized queries"
    }
  },
  exploitation_attempt: {
    success: true,
    technique: "union-based",
    payload: "' UNION SELECT username,password FROM users--",
    response_snippet: "admin:$2b$12$..."
  }
});
```

### Verifying Remediation

After retesting a fixed vulnerability:

```javascript
await verify_remediation({
  hostname: "example.com",
  vulnerability_id: "abc123...",
  new_status: "verified",
  verification_method: "Attempted exploitation with previous payload",
  notes: "Parameterized queries now in use, injection blocked"
});
```

## Performance

- Database queries: < 500ms target
- Deduplication: O(1) hash lookup
- Credential extraction: Regex-based, fast
- Connection pooling: One connection per hostname

## Security Considerations

1. **Password Hashing**: All passwords are hashed with bcrypt (10 rounds)
2. **File Permissions**: Database files are chmod 600
3. **Sensitive Data**: Connection strings stored but passwords hashed
4. **Access Control**: Only agents have access via MCP tools

## Troubleshooting

### Database Locked Errors

WAL mode should prevent this, but if you encounter database locks:
- Check that only one Shaart process is running per hostname
- Ensure proper cleanup of database connections

### Missing Historical Data

- Verify `exploit_memory.enabled: true` in config
- Check database file exists in `exploit-memory/` directory
- Ensure proper hostname format (no protocol, just domain)

### Credential Extraction Not Working

- Verify evidence files contain credentials in supported formats
- Check that patterns match your credential format
- Review credential-extractor.js regex patterns

## Migration Notes

The exploit memory system is backwards compatible. Existing sessions without exploit memory will continue to work normally. New sessions will automatically create and populate the database.

## Future Enhancements

Potential future improvements:
- Cross-application pattern learning
- Machine learning for vulnerability prediction
- Automatic remediation verification
- Integration with external vulnerability databases
- Export/import functionality for sharing findings
