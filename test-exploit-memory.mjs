#!/usr/bin/env node
/**
 * Manual test script for exploit memory system
 * Tests: database, deduplication, MCP tools, credential extraction
 */

import { getDatabase, closeAllDatabases, upsertApplication, upsertVulnerability, recordExploitationAttempt } from './src/exploit-memory/database.js';
import { generateIdentityHash, normalizeVulnerability } from './src/exploit-memory/deduplicator.js';
import { extractCredentials } from './src/exploit-memory/credential-extractor.js';

const hostname = 'test-app.example.com';
const sessionId = 'test-session-123';

console.log('\nüß™ Testing Exploit Memory System\n');
console.log('='.repeat(50));

// Test 1: Database & Schema
console.log('\n[1/6] Testing Database Creation...');
try {
  const db = getDatabase(hostname);
  console.log('‚úÖ Database created for', hostname);

  const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
  console.log(`‚úÖ Found ${tables.length} tables:`, tables.map(t => t.name).join(', '));
} catch (e) {
  console.error('‚ùå Database test failed:', e.message);
  process.exit(1);
}

// Test 2: Application Upsert
console.log('\n[2/6] Testing Application Upsert...');
try {
  const db = getDatabase(hostname);
  upsertApplication(db, {
    hostname,
    tech_stack: ['Python', 'FastAPI', 'PostgreSQL'],
    common_weaknesses: ['sql_injection']
  });
  console.log('‚úÖ Application record created');
} catch (e) {
  console.error('‚ùå Application upsert failed:', e.message);
  closeAllDatabases();
  process.exit(1);
}

// Test 3: Vulnerability Deduplication
console.log('\n[3/6] Testing Vulnerability Deduplication...');
try {
  const vuln1 = {
    hostname,
    vuln_type: 'sql_injection',
    source: 'api/users.py:45',
    path: '/api/users',
    sink_call: 'db.execute',
    confidence: 95
  };

  const normalized = normalizeVulnerability(vuln1);
  const hash1 = generateIdentityHash(normalized);
  console.log('‚úÖ Identity hash generated:', hash1.substring(0, 16) + '...');

  // Same vuln with line number changed - should have SAME hash
  const vuln2 = { ...vuln1, source: 'api/users.py:50' };
  const hash2 = generateIdentityHash(normalizeVulnerability(vuln2));

  if (hash1 === hash2) {
    console.log('‚úÖ Deduplication works: line numbers ignored');
  } else {
    throw new Error('Deduplication failed: hashes differ');
  }

  // Different vuln - should have DIFFERENT hash
  const vuln3 = { ...vuln1, path: '/api/posts' };
  const hash3 = generateIdentityHash(normalizeVulnerability(vuln3));

  if (hash1 !== hash3) {
    console.log('‚úÖ Different vulnerabilities have different hashes');
  } else {
    throw new Error('Deduplication too aggressive: different vulns have same hash');
  }
} catch (e) {
  console.error('‚ùå Deduplication test failed:', e.message);
  closeAllDatabases();
  process.exit(1);
}

// Test 4: Vulnerability Storage
console.log('\n[4/6] Testing Vulnerability Storage...');
try {
  const db = getDatabase(hostname);

  const vuln = {
    hostname,
    vuln_type: 'sql_injection',
    source: 'api/users.py:45',
    path: '/api/users',
    sink_call: 'db.execute',
    confidence: 95,
    exploitation_data: {
      description: 'SQL injection in user search',
      impact: 'Full database access',
      remediation: 'Use parameterized queries'
    }
  };

  // Generate identity hash
  const normalized = normalizeVulnerability(vuln);
  const vulnerabilityId = generateIdentityHash(normalized);

  // Store vulnerability
  upsertVulnerability(db, {
    id: vulnerabilityId,
    hostname,
    ...vuln
  });

  console.log('‚úÖ Vulnerability stored:', vulnerabilityId.substring(0, 16) + '...');

  // Record exploitation attempt
  recordExploitationAttempt(db, {
    vulnerability_id: vulnerabilityId,
    session_id: sessionId,
    success: true,
    technique: 'union-based',
    payload: "' UNION SELECT username,password FROM users--",
    response_snippet: 'admin:$2b$12$...'
  });

  // Query it back
  const stored = db.prepare('SELECT * FROM vulnerabilities WHERE id = ?').get(vulnerabilityId);

  if (stored) {
    console.log('‚úÖ Vulnerability retrieved from database');
    console.log(`   Type: ${stored.vuln_type}, Confidence: ${stored.confidence}%`);
  } else {
    throw new Error('Failed to retrieve stored vulnerability');
  }

  // Check exploitation attempt
  const attempt = db.prepare('SELECT * FROM exploitation_attempts WHERE vulnerability_id = ?').get(vulnerabilityId);
  if (attempt && attempt.success) {
    console.log('‚úÖ Exploitation attempt recorded');
    console.log(`   Technique: ${attempt.technique}, Success: ${attempt.success}`);
  } else {
    throw new Error('Failed to retrieve exploitation attempt');
  }

  // Store same vulnerability again - should update, not create new
  upsertVulnerability(db, {
    id: vulnerabilityId,
    hostname,
    ...vuln,
    confidence: 98 // Higher confidence
  });

  // Record another attempt
  recordExploitationAttempt(db, {
    vulnerability_id: vulnerabilityId,
    session_id: sessionId,
    success: true,
    technique: 'error-based',
    payload: "' AND 1=CAST((SELECT username FROM users LIMIT 1) AS INT)--"
  });

  const updated = db.prepare('SELECT * FROM vulnerabilities WHERE id = ?').get(vulnerabilityId);
  if (updated && updated.confidence === 98) {
    console.log('‚úÖ Duplicate vulnerability updated (confidence increased)');

    const attempts = db.prepare('SELECT COUNT(*) as count FROM exploitation_attempts WHERE vulnerability_id = ?').get(vulnerabilityId);
    console.log(`‚úÖ Multiple attempts tracked: ${attempts.count} attempts`);
  } else {
    throw new Error('Deduplication failed: vulnerability not updated correctly');
  }

} catch (e) {
  console.error('‚ùå Vulnerability storage test failed:', e.message);
  console.error(e.stack);
  closeAllDatabases();
  process.exit(1);
}

// Test 5: Credential Extraction
console.log('\n[5/6] Testing Credential Extraction...');
try {
  const evidenceText = `
    Database connection string: postgresql://admin:secret123@db.example.com:5432/production
    API Key found: sk-live-abc123def456ghi789
    AWS Access Key: AKIAIOSFODNN7EXAMPLE
  `;

  const credentials = extractCredentials(evidenceText);
  console.log(`‚úÖ Extracted ${credentials.length} credentials`);

  for (const cred of credentials) {
    console.log(`   - ${cred.credential_type} (${cred.service_type || 'N/A'})`);
  }

  if (credentials.length === 0) {
    console.warn('‚ö†Ô∏è  Warning: No credentials extracted (patterns may need adjustment)');
  }
} catch (e) {
  console.error('‚ùå Credential extraction test failed:', e.message);
  closeAllDatabases();
  process.exit(1);
}

// Test 6: Query Historical Data
console.log('\n[6/6] Testing Historical Query...');
try {
  const db = getDatabase(hostname);

  // Query all vulnerabilities
  const vulns = db.prepare(`
    SELECT v.*, COUNT(e.id) as attempt_count
    FROM vulnerabilities v
    LEFT JOIN exploitation_attempts e ON v.id = e.vulnerability_id
    WHERE v.hostname = ?
    GROUP BY v.id
  `).all(hostname);

  console.log(`‚úÖ Found ${vulns.length} vulnerabilities for ${hostname}`);

  for (const vuln of vulns) {
    console.log(`   - ${vuln.vuln_type} at ${vuln.path} (${vuln.attempt_count} attempts, ${vuln.confidence}% confidence)`);
  }

  // Query by type
  const sqlInjections = db.prepare(`
    SELECT COUNT(*) as count FROM vulnerabilities
    WHERE hostname = ? AND vuln_type = ?
  `).get(hostname, 'sql_injection');

  console.log(`‚úÖ SQL injections found: ${sqlInjections.count}`);

  // Query successful attempts
  const successful = db.prepare(`
    SELECT v.path, e.technique, e.payload
    FROM vulnerabilities v
    JOIN exploitation_attempts e ON v.id = e.vulnerability_id
    WHERE v.hostname = ? AND e.success = 1
    LIMIT 5
  `).all(hostname);

  console.log(`‚úÖ Successful exploits: ${successful.length}`);
  for (const s of successful) {
    console.log(`   - ${s.path} via ${s.technique}`);
  }

} catch (e) {
  console.error('‚ùå Query test failed:', e.message);
  closeAllDatabases();
  process.exit(1);
}

// Cleanup
console.log('\n' + '='.repeat(50));
console.log('üßπ Cleaning up test data...');
closeAllDatabases();

// Delete test database
import { fs } from 'zx';
const dbPath = `./exploit-memory/${hostname}.db`;
if (fs.existsSync(dbPath)) {
  fs.unlinkSync(dbPath);
  if (fs.existsSync(`${dbPath}-shm`)) fs.unlinkSync(`${dbPath}-shm`);
  if (fs.existsSync(`${dbPath}-wal`)) fs.unlinkSync(`${dbPath}-wal`);
  console.log('‚úÖ Test database deleted');
}

console.log('\n‚úÖ All tests passed!\n');
